package org.mql.spring.jdbc;

import java.lang.reflect.Field;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.Statement;

public class Database {
	
	private DataSource dataSource;
	private Connection db;
	
	public Database(DataSource dataSource) {
		this.dataSource=dataSource;
		db=dataSource.getConnection();
	}
	
	public void setDatabase(DataSource dataSource) {
		this.dataSource=dataSource;
		db=dataSource.getConnection();
	}
	
	public DataSource getSource() {
		return dataSource;
	}
	
	public String[][] query(String request) {
		try {
			// SQL Statement est simplement une instruction qui dit à la base de données quoi faire
			Statement sql= db.createStatement(ResultSet.TYPE_SCROLL_INSENSITIVE, ResultSet.CONCUR_READ_ONLY);
			
			/*	Un ResultSet agit comme une table temporaire en mémoire qui permet de :

				Lire les données récupérées depuis la base de données.
				
				Naviguer entre les lignes et colonnes.
				
				Extraire les valeurs via différents types de données.
			*/
			ResultSet rs= sql.executeQuery(request);
			int rows, cols; // Pour stocker le nombre des lignes et les colonnes de rs 
			rs.last(); // Se positionner au denier element de rs afin de récuperer le nombre des lignes  
			rows=rs.getRow(); // Récuperer le nombre des lignes 
			rs.beforeFirst(); // Retourner à l'element avant le premier pour recuperer les valeurs 
			
			
			ResultSetMetaData rsm=rs.getMetaData(); // MetaData pour récuperer le npmbre des colonnes
			cols=rsm.getColumnCount();
			
			String data[][]= new String[rows+1][cols]; // Initialiser une matrice 2D où nous allons stocker les données récuperées  
			 
			// Récuperer la première ligne qui est dédiée pour le nom des colonnes
			for (int i = 0; i < cols; i++) {
				data[0][i]=rsm.getColumnName(i+1);
			}
			
			int row=0;
			
			// Boucler en tant que le next n'est pas null
			while(rs.next()) {
				row++;
				for (int col = 0; col < cols; col++) {
					data[row][col]=rs.getString(col+1);
				}
			}
			sql.close();
			return data;
		} catch (Exception e) {
			System.out.println("Erreur : "+e.getMessage());
			return null;
		}
	}
	
	public String[][] select(String tableName) {
		String request="SELECT * FROM "+ tableName;
		return query(request);
	}
	
	public String[][] selectBykeyword(String tableName, String key, Object value) {
		String request="SELECT * FROM "+ tableName + " WHERE " + key + " LIKE '% " + value + " %'";
		return query(request);
	}
	
	//La suite des méthodes select ()...
	
	public boolean insert(String tableName, Object...row ) {
		String query="INSERT INTO "+tableName+" VALUES('"+row[0]+"'" ;
		for (int i = 1; i < row.length; i++) {
			query+= ", '"+row[i]+"'";
		}
		query +=")";
		try {
			Statement sql = db.createStatement();
			int result = sql.executeUpdate(query);
			if(result==1 ) return true;
			return false;
		} catch (Exception e) {
			System.out.println("Erreur: "+e.getMessage());
			return false;
		}
	}
	
	public boolean insert(String tableName, Object model ) {
		
		try {
			Field fields[]= model.getClass().getDeclaredFields();
			Object row[]=new Object[fields.length];
			for (int i = 0; i < row.length; i++) {
				fields[i].setAccessible(true);
				row[i]=fields[i].get(model);
				fields[i].setAccessible(false);
			}
			return insert(tableName,row);
		} catch (Exception e) {
			System.out.println("Erreur: "+e.getMessage());
			return false;
		}
	}
	
}
